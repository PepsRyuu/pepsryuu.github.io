var ScrollOffsetAnimationCurve = (function () {

    // Wrapping the component like this so that it gets properly tree-shaken.
    // Without this wrapping, things like the license could leak even when not used in the bundle.

    /**
     * Code based off the scroll_offset_animation_curve.cc from Chromium project.
     * https://chromium.googlesource.com/chromium/src/+/69.0.3476.1/cc/animation/scroll_offset_animation_curve.cc
     */

    /*!
     * Copyright 2015 The Chromium Authors. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *    * Redistributions of source code must retain the above copyright
     * notice, this list of conditions and the following disclaimer.
     *    * Redistributions in binary form must reproduce the above
     * copyright notice, this list of conditions and the following disclaimer
     * in the documentation and/or other materials provided with the
     * distribution.
     *    * Neither the name of Google Inc. nor the names of its
     * contributors may be used to endorse or promote products derived from
     * this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */

    var kConstantDuration = 9.0;
    var kDurationDivisor = 60.0;
    var kInverseDeltaRampStartPx = 120.0;
    var kInverseDeltaRampEndPx = 480.0;
    var kInverseDeltaMinDuration = 6.0;
    var kInverseDeltaMaxDuration = 12.0;
    var kInverseDeltaSlope = (kInverseDeltaMinDuration - kInverseDeltaMaxDuration) / (kInverseDeltaRampEndPx - kInverseDeltaRampStartPx);
    var kInverseDeltaOffset = kInverseDeltaMaxDuration - kInverseDeltaRampStartPx * kInverseDeltaSlope;
    var kEpsilon = 0.01;
    var kBezierEpsilon = 1e-7;

    function MaximumDimension (delta) {
        return Math.abs(delta.x) > Math.abs(delta.y) ? delta.x : delta.y;
    }

    function EaseOutWithInitialVelocity (velocity) {
        // Clamp velocity to a sane value.
        velocity = Math.min(Math.max(velocity, -1000), 1000);

        // Based on CubicBezierTimingFunction::EaseType::EASE_IN_OUT preset
        // with first control point scaled.
        var x1 = 0.42;
        var y1 = velocity * x1;
        return new CubicBezierTimingFunction('ease-type', x1, y1, 0.58, 1);
    }

    function ScrollOffset(x, y) {
        return {x: x, y: y};
    }

    function ScrollOffsetWithDelta(offset, delta) {
        return ScrollOffset(offset.x + delta.x, offset.y + delta.y);
    }

    function tween(value, start, target) {
        return (start + (target - start) * value);
    }

    function VelocityBasedDurationBound (old_delta, old_normalized_velocity, old_duration, new_delta) {
        var old_delta_max_dimension = MaximumDimension(old_delta);
        var new_delta_max_dimension = MaximumDimension(new_delta);

        if (Math.abs(new_delta_max_dimension) < kEpsilon) {
            return 0;
        }

        if (Math.abs(old_delta_max_dimension) < kEpsilon || Math.abs(old_normalized_velocity) < kEpsilon) {
            return Number.POSITIVE_INFINITY;
        }

        var old_true_velocity = old_normalized_velocity * old_delta_max_dimension / old_duration;
        var bound = (new_delta_max_dimension / old_true_velocity) * 2.5;

        return bound < 0 ? Number.POSITIVE_INFINITY : bound;
    }


    function DeltaFrom(v1, v2) {
        return ScrollOffset(v1.x - v2.x, v1.y - v2.y);
    }


    var CubicBezier = function CubicBezier(p1x, p1y, p2x, p2y) {
        this.InitCoefficients(p1x, p1y, p2x, p2y);
        this.InitGradients(p1x, p1y, p2x, p2y);
        this.InitRange(p1y, p2y);
    };

    CubicBezier.prototype.InitCoefficients = function InitCoefficients (p1x, p1y, p2x, p2y) {
        this.cx = 3.0 * p1x;
        this.bx = 3.0 * (p2x - p1x) - this.cx;
        this.ax = 1.0 - this.cx - this.bx;

        this.cy = 3.0 * p1y;
        this.by = 3.0 * (p2y - p1y) - this.cy;
        this.ay = 1.0 - this.cy - this.by;
    };

    CubicBezier.prototype.InitGradients = function InitGradients (p1x, p1y, p2x, p2y) {
        // End-point gradients are used to calculate timing function results
        // outside the range [0, 1].
        //
        // There are three possibilities for the gradient at each end:
        // (1) the closest control point is not horizontally coincident with regard to
        // (0, 0) or (1, 1). In this case the line between the end point and
        // the control point is tangent to the bezier at the end point.
        // (2) the closest control point is coincident with the end point. In
        // this case the line between the end point and the far control
        // point is tangent to the bezier at the end point.
        // (3) the closest control point is horizontally coincident with the end
        // point, but vertically distinct. In this case the gradient at the
        // end point is Infinite. However, this causes issues when
        // interpolating. As a result, we break down to a simple case of
        // 0 gradient under these conditions.

        if (p1x > 0)
            { this.start_gradient = p1y / p1x; }
        else if (!p1y && p2x > 0)
            { this.start_gradient = p2y / p2x; }
        else
            { this.start_gradient = 0; }

        if (p2x < 1)
            { this.end_gradient = (p2y - 1) / (p2x - 1); }
        else if (p2x == 1 && p1x < 1)
            { this.end_gradient = (p1y - 1) / (p1x - 1); }
        else
            { this.end_gradient = 0; }
    };

    CubicBezier.prototype.InitRange = function InitRange (p1y, p2y) {
        this.range_min = 0;
        this.range_max = 1;
        if (0 <= p1y && p1y < 1 && 0 <= p2y && p2y <= 1)
            { return; }

        var epsilon = kBezierEpsilon;

        // Represent the function's derivative in the form at^2 + bt + c
        // as in sampleCurveDerivativeY.
        // (Technically this is (dy/dt)*(1/3), which is suitable for finding zeros
        // but does not actually give the slope of the curve.)
        var a = 3.0 * this.ay;
        var b = 2.0 * this.by;
        var c = this.c_;

        // Check if the derivative is constant.
        if (Math.abs(a) < epsilon && Math.abs(b) < epsilon)
            { return; }

        // Zeros of the function's derivative.
        var t1 = 0;
        var t2 = 0;

        if (Math.abs(a) < epsilon) {
            // The function's derivative is linear.
            t1 = -c / b;
        } else {
            // The function's derivative is a quadratic. We find the zeros of this
            // quadratic using the quadratic formula.
            var discriminant = b * b - 4 * a * c;
            if (discriminant < 0)
                { return; }

            var discriminant_sqrt = Math.sqrt(discriminant);
            t1 = (-b + discriminant_sqrt) / (2 * a);
            t2 = (-b - discriminant_sqrt) / (2 * a);
        }

        var sol1 = 0;
        var sol2 = 0;

        // If the solution is in the range [0,1] then we include it, otherwise we
        // ignore it.

        // An interesting fact about these beziers is that they are only
        // actually evaluated in [0,1]. After that we take the tangent at that point
        // and linearly project it out.
        if (0 < t1 && t1 < 1)
            { sol1 = this.SampleCurveY(t1); }

        if (0 < t2 && t2 < 1)
            { sol2 = this.SampleCurveY(t2); }

        this.range_min = Math.min(Math.min(this.range_min, sol1), sol2);
        this.range_max = Math.max(Math.max(this.range_max, sol1), sol2);
    };

    CubicBezier.prototype.SampleCurveY = function SampleCurveY (t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
    };

    CubicBezier.prototype.SampleCurveX = function SampleCurveX (t) {
        return ((this.ax * t + this.bx) * t + this.cx) * t;
    };

    CubicBezier.prototype.SampleCurveDerivativeX = function SampleCurveDerivativeX (t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
    };

    CubicBezier.prototype.SampleCurveDerivativeY = function SampleCurveDerivativeY (t) {
        return (3.0 * this.ay * t + 2.0 * this.by) * t + this.cy;
    };

    CubicBezier.prototype.GetDefaultEpsilon = function GetDefaultEpsilon () {
        return kBezierEpsilon;
    };

    CubicBezier.prototype.SolveCurveX = function SolveCurveX (x, epsilon) {
            var this$1 = this;

        var t0;
        var t1;
        var t2;
        var x2;
        var d2;
        var i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = this$1.SampleCurveX(t2) - x;

            if (Math.abs(x2) < epsilon)
                { return t2; }

            d2 = this$1.SampleCurveDerivativeX(t2);
                
            if (Math.abs(d2) < 1e-6)
                { break; }

            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        while (t0 < t1) {
            x2 = this$1.SampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon)
                { return t2; }
            if (x > x2)
                { t0 = t2; }
            else
                { t1 = t2; }
            t2 = (t1 - t0) * 0.5 + t0;
        }

        // Failure.
        return t2;
    };

    CubicBezier.prototype.Solve = function Solve (x) {
        return this.SolveWithEpsilon(x, kBezierEpsilon);
    };

    CubicBezier.prototype.SolveWithEpsilon = function SolveWithEpsilon (x, epsilon) {
        if (x < 0.0)
            { return 0.0 + this.start_gradient * x; }
        if (x > 1.0)
            { return 1.0 + this.end_gradient * (x - 1.0); }
        return this.SampleCurveY(this.SolveCurveX(x, epsilon));
    };

    CubicBezier.prototype.SlopeWithEpsilon = function SlopeWithEpsilon (x, epsilon) {
        x = Math.min(Math.max(x, 0.0), 1.0);
        var t = this.SolveCurveX(x, epsilon);
        var dx = this.SampleCurveDerivativeX(t);
        var dy = this.SampleCurveDerivativeY(t);
        return dy / dx;
    };

    CubicBezier.prototype.Slope = function Slope (x) {
        return this.SlopeWithEpsilon(x, kBezierEpsilon);
    };

    CubicBezier.prototype.GetX1 = function GetX1 () {
        return this.cx / 3.0;
    };

    CubicBezier.prototype.GetY1 = function GetY1 () {
        return this.cy / 3.0;
    };

    CubicBezier.prototype.GetX2 = function GetX2 () {
        return (this.bx + this.cx) / 3.0 + this.GetX1()
    };

    CubicBezier.prototype.GetY2 = function GetY2 () {
        return (this.by + this.cy) / 3.0 + this.GetY1();
    };

    var DurationBehaviour = {
        CONSTANT: 0,
        DELTA_BASED: 1,
        INVERSE_DELTA: 2
    };

    var CubicBezierTimingFunction = function CubicBezierTimingFunction (ease_type, x1, y1, x2, y2) {
        this.bezier = new CubicBezier(x1, y1, x2, y2);
        this.ease_type = ease_type;
    };

    CubicBezierTimingFunction.prototype.GetType = function GetType () {
        return 'CUBIC_BEZIER';
    };

    CubicBezierTimingFunction.prototype.GetValue = function GetValue (x) {
        return this.bezier.Solve(x);
    };

    CubicBezierTimingFunction.prototype.Velocity = function Velocity (x) {
        return this.bezier.Slope(x);
    };

    var AnimationCurve = function AnimationCurve (target_value, timing_function, duration_behaviour) {
        if ( duration_behaviour === void 0 ) duration_behaviour = DurationBehaviour.DELTA_BASED;

        this.initial_value = 0;
        this.target_value = target_value;
        this.total_animation_duration = 0;
        this.last_retarget = 0;
        this.timing_function = timing_function;
        this.duration_behaviour = duration_behaviour;
        this.has_set_initial_value = false;
    };

    AnimationCurve.prototype.SegmentDuration = function SegmentDuration (delta, behaviour, delayed_by) {
        var duration = kConstantDuration;

        switch (behaviour) {
            case DurationBehaviour.CONSTANT: 
                duration = kConstantDuration;
                break;

            case DurationBehaviour.DELTA_BASED:
                duration = Math.sqrt(Math.abs(MaximumDimension(delta)));
                break;

            case DurationBehaviour.INVERSE_DELTA:
                duration = Math.min(Math.max(kInverseDeltaOffset + Math.abs(MaximumDimension(delta)) * kInverseDeltaSlope, kInverseDeltaMinDuration), kInverseDeltaMaxDuration);
                break;
        }

        var time_delta = duration / kDurationDivisor;
        time_delta -= delayed_by;

        if (time_delta >= 0) { // base delta
            return time_delta;
        }

        return 0; // base_delta
    };

    AnimationCurve.prototype.SetInitialValue = function SetInitialValue (initial_value, delayed_by) {
            if ( delayed_by === void 0 ) delayed_by = 0;
// time delta for delayed by
        this.initial_value = initial_value;
        this.has_set_initial_value = true;
        this.total_animation_duration = this.SegmentDuration(DeltaFrom(this.target_value, this.initial_value), this.duration_behaviour, delayed_by);
    };

    AnimationCurve.prototype.HasSetInitialValue = function HasSetInitialValue () {
        return this.has_set_initial_value;
    };    

    AnimationCurve.prototype.ApplyAdjustment = function ApplyAdjustment (adjustment) {
        this.initial_value = ScrollOffsetWithDelta(this.initial_value, adjustment);
        this.target_value = ScrollOffsetWithDelta(this.target_value, adjustment);
    };

    AnimationCurve.prototype.GetValue = function GetValue (t) {
        var duration = this.total_animation_duration - this.last_retarget;
        t -= this.last_retarget;

        if (duration === 0) {
            return this.target_value;
        }

        if (t <= 0) // base-delta
            { return this.initial_value; }

        if (t >= duration) {
            return this.target_value;
        }

        var progress = this.timing_function.GetValue(t / duration);

        var x = tween(progress, this.initial_value.x, this.target_value.x);
        var y = tween(progress, this.initial_value.y, this.target_value.y);
        return ScrollOffset(x, y);
    };

    AnimationCurve.prototype.Duration = function Duration () {
        return this.total_animation_duration;
    };

    AnimationCurve.prototype.UpdateTarget = function UpdateTarget (t, new_target) {
        if (Math.abs(MaximumDimension(DeltaFrom(this.target_value, new_target))) < kEpsilon) {
            this.target_value = new_target;
            return;
        }

        var delayed_by = Math.max(0, this.last_retarget - t);
        t = Math.max(t, this.last_retarget);

        var current_position = this.GetValue(t);
        var old_delta = DeltaFrom(this.target_value, this.initial_value);
        var new_delta = DeltaFrom(new_target, current_position);

        if (this.total_animation_duration - this.last_retarget === 0) {
            this.total_animation_duration = this.SegmentDuration(new_delta, this.duration_behaviour, delayed_by);
            this.target_value = new_target;
            return;
        }

        var old_duration = this.total_animation_duration - this.last_retarget;
        var old_normalized_velocity = this.timing_function.Velocity((t - this.last_retarget) / old_duration);

        // Use the velocity-based duration bound when it is less than the constant
        // segment duration. This minimizes the "rubber-band" bouncing effect when
        // old_normalized_velocity is large and new_delta is small.
        var new_duration = Math.min(this.SegmentDuration(new_delta, this.duration_behaviour, delayed_by), VelocityBasedDurationBound(old_delta, old_normalized_velocity, old_duration, new_delta));

        if (new_duration < kEpsilon) {
            this.target_value = new_target;
            this.total_animation_duration = t; // TimeDelta::FromSecondsD(t);
            return;
        }

        var new_normalized_velocity = old_normalized_velocity * (new_duration / old_duration) * (MaximumDimension(old_delta) / MaximumDimension(new_delta));

        this.initial_value = current_position;
        this.target_value = new_target;
        this.total_animation_duration = t + new_duration;
        this.last_retarget = t;
        this.timing_function = EaseOutWithInitialVelocity(new_normalized_velocity);

    };

    return { DurationBehaviour: DurationBehaviour, AnimationCurve: AnimationCurve, CubicBezierTimingFunction: CubicBezierTimingFunction};
})();

function createPrivateStore () {
    var store = new WeakMap();

    return function (inst) {
        var obj = store.get(inst);

        if (!obj) {
            obj = {};
            store.set(inst, obj);
        }
        return obj;
    }; 
}

var _ = createPrivateStore();
var CubicBezierTimingFunction = ScrollOffsetAnimationCurve.CubicBezierTimingFunction;
var DurationBehaviour = ScrollOffsetAnimationCurve.DurationBehaviour;
var AnimationCurve = ScrollOffsetAnimationCurve.AnimationCurve;

var ScrollbarAnimator = function ScrollbarAnimator (options) {
    if ( options === void 0 ) options = {};

    // initial, maximum, onAnimationFrame
    _(this).timing_fn = new CubicBezierTimingFunction('EASE_IN_OUT', 0.42, 0.0, 0.58, 1);
    _(this).onPositionRequest = options.onPositionRequest || (function () { return 0; });
    _(this).onMaximumRequest = options.onMaximumRequest || (function () { return Number.Infinity; });
    _(this).onAnimationFrame = options.onAnimationFrame || (function () {});
};

ScrollbarAnimator.prototype.scroll = function scroll (delta) {
        var this$1 = this;

    var maximum = _(this).onMaximumRequest();

    if (_(this).animating) {
        var currTime = (Date.now() - _(this).startTime) / 1000;
        _(this).target = Math.min(_(this).target + delta, maximum);
        _(this).curve.UpdateTarget(currTime, {x: 0, y: _(this).target});
    } else {
        var startPos = _(this).onPositionRequest();
        _(this).target = Math.min(startPos + delta, maximum);
        _(this).curve = new AnimationCurve({ x: 0, y: _(this).target }, _(this).timing_fn, DurationBehaviour.INVERSE_DELTA );
        _(this).startTime = Date.now();
        _(this).curve.SetInitialValue({x: 0, y: startPos});

        var loop = function () {
            var deltaTime = (Date.now() - _(this$1).startTime) / 1000;
            var value = _(this$1).curve.GetValue(deltaTime);

            _(this$1).onAnimationFrame(value.y);

            if (value.y === _(this$1).target) {
                delete _(this$1).animating;
            } else {    
                _(this$1).animating = requestAnimationFrame(loop);
            }
        };

        _(this).animating = requestAnimationFrame(loop);
    }
};

export default ScrollbarAnimator;
